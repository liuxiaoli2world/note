## 漫画：什么是漫画动态规划？（整合版）

![img](漫画动态规划.assets/640.webp)





![img](漫画动态规划.assets/640.webp)





![img](漫画动态规划.assets/640-1564452967171.webp)





![img](漫画动态规划.assets/640-1564452967206.webp)





————————————







![img](漫画动态规划.assets/640-1564452967225.webp)





![img](漫画动态规划.assets/640-1564452967249.webp)





![img](漫画动态规划.assets/640-1564452967260.webp)





**题目：**



有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。



比如，每次走1级台阶，一共走10步，这是其中一种走法。我们可以简写成 1,1,1,1,1,1,1,1,1,1。





![img](漫画动态规划.assets/640-1564452967270.webp)



再比如，每次走2级台阶，一共走5步，这是另一种走法。我们可以简写成 2,2,2,2,2。





![img](漫画动态规划.assets/640-1564452967278.webp)



当然，除此之外，还有很多很多种走法。





![img](漫画动态规划.assets/640-1564452967288.webp)





![img](漫画动态规划.assets/640-1564452967297.webp)





![img](漫画动态规划.assets/640-1564452967306.webp)





![img](漫画动态规划.assets/640-1564452967288.webp)





![img](漫画动态规划.assets/640-1564452967345.webp)





![img](漫画动态规划.assets/640-1564452967347.webp)





————————————





![img](漫画动态规划.assets/640-1564452967360.webp)





![img](漫画动态规划.assets/640-1564452967384.webp)





![img](漫画动态规划.assets/640-1564452967387.webp)





![img](漫画动态规划.assets/640-1564452967395.webp)





![img](漫画动态规划.assets/640-1564452967409.webp)





![img](漫画动态规划.assets/640-1564452967419.webp)





![img](漫画动态规划.assets/640-1564452967426.webp)





**第一种情况：**





![img](漫画动态规划.assets/640-1564452967438.webp)



**第二种情况：**





![img](漫画动态规划.assets/640-1564452967453.webp)





![img](漫画动态规划.assets/640-1564452967464.webp)





![img](漫画动态规划.assets/640-1564452967473.webp)





![img](漫画动态规划.assets/640-1564452967488.webp)





![img](漫画动态规划.assets/640-1564452967502.webp)





![img](漫画动态规划.assets/640-1564452967510.webp)





**把思路画出来，就是这样子：**





![img](漫画动态规划.assets/640-1564452967517.webp)





![img](漫画动态规划.assets/640-1564452967539.webp)





![img](漫画动态规划.assets/640-1564452967543.webp)





![img](漫画动态规划.assets/640-1564452967551.webp)



![img](漫画动态规划.assets/640-1564452967564.webp)





![img](漫画动态规划.assets/640-1564452967574.webp)





**F(1) = 1;**

**F(2) = 2;** 

**F(n) = F(n-1)+F(n-2)（n>=3）**





![img](漫画动态规划.assets/640-1564452967589.webp)





![img](漫画动态规划.assets/640-1564452967600.webp)





![img](漫画动态规划.assets/640-1564452967613.webp)





![img](漫画动态规划.assets/640-1564452967623.webp)





![img](漫画动态规划.assets/640-1564452967641.webp)





![img](漫画动态规划.assets/640-1564452967649.webp)





![img](漫画动态规划.assets/640-1564452967660.webp)





![img](漫画动态规划.assets/640-1564452967675.webp)





![img](漫画动态规划.assets/640-1564452967689.webp)





**方法一：递归求解**



![img](漫画动态规划.assets/640-1564452967701.webp)



由于代码比较简单，这里就不做过多解释了。





![img](漫画动态规划.assets/640-1564452967715.webp)





![img](漫画动态规划.assets/640-1564452967725.webp)





![img](漫画动态规划.assets/640-1564452967743.webp)





![img](漫画动态规划.assets/640-1564452967752.webp)





![img](漫画动态规划.assets/640-1564452967775.webp)





![img](漫画动态规划.assets/640-1564452967772.webp)





![img](漫画动态规划.assets/640-1564452967789.webp)





![img](漫画动态规划.assets/640-1564452967797.webp)





![img](漫画动态规划.assets/640-1564452967812.webp)





![img](漫画动态规划.assets/640-1564452967821.webp)





![img](漫画动态规划.assets/640-1564452967843.webp)





![img](漫画动态规划.assets/640-1564452967853.webp)





如图所示，相同的颜色代表了方法被传入相同的参数。





![img](漫画动态规划.assets/640-1564452967861.webp)





![img](漫画动态规划.assets/640-1564452967881.webp)





![img](漫画动态规划.assets/640-1564452967888.webp)





**方法二：备忘录算法**



![img](漫画动态规划.assets/640-1564452967899.webp)



在以上代码中，集合map是一个备忘录。当每次需要计算F(N)的时候，会首先从map中寻找匹配元素。如果map中存在，就直接返回结果，如果map中不存在，就计算出结果，存入备忘录中。





![img](漫画动态规划.assets/640-1564452967913.webp)





![img](漫画动态规划.assets/640-1564452967924.webp)





![img](漫画动态规划.assets/640-1564452967940.webp)





![img](漫画动态规划.assets/640-1564452967950.webp)





![img](漫画动态规划.assets/640-1564452967959.webp)





![img](漫画动态规划.assets/640-1564452967971.webp)





![img](漫画动态规划.assets/640-1564452967978.webp)





![img](漫画动态规划.assets/640-1564452967992.webp)





![img](漫画动态规划.assets/640-1564452968002.webp)





![img](漫画动态规划.assets/640-1564452968015.webp)





![img](漫画动态规划.assets/640-1564452968025.webp)





![img](漫画动态规划.assets/640-1564452968038.webp)





![img](漫画动态规划.assets/640-1564452968048.webp)





![img](漫画动态规划.assets/640-1564452968061.webp)





![img](漫画动态规划.assets/640-1564452968066.webp)





![img](漫画动态规划.assets/640-1564452968090.webp)





![img](漫画动态规划.assets/640-1564452968088.webp)





![img](漫画动态规划.assets/640-1564452968103.webp)





![img](漫画动态规划.assets/640-1564452968114.webp)





![img](漫画动态规划.assets/640-1564452968134.webp)





![img](漫画动态规划.assets/640-1564452968144.webp)





![img](漫画动态规划.assets/640-1564452968152.webp)





**方法三：漫画动态规划求解**



![img](漫画动态规划.assets/640-1564452968163.webp)



程序从 i=3 开始迭代，一直到 i=n 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量a和b，分别代表了上一次和上上次迭代的结果。 为了便于理解，我引入了temp变量。temp代表了当前迭代的结果值。





![img](漫画动态规划.assets/640-1564452968193.webp)





![img](漫画动态规划.assets/640-1564452968186.webp)





![img](漫画动态规划.assets/640-1564452968202.webp)





![img](漫画动态规划.assets/640-1564452968210.webp)





![img](漫画动态规划.assets/640-1564452968235.webp)





![img](漫画动态规划.assets/640-1564452968221.webp)





![img](漫画动态规划.assets/640-1564452968246.webp)





**题目二： 国王和金矿**



有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？





![img](漫画动态规划.assets/640-1564452968253.webp)





![img](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqsVLVAGiawEcO72GZiaUAPGM1VtuVl6ZKgIrfeIt9aSWQp6NRoRiakZ1CjTgT8jfbLYmVib6zlj0ricOg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





![img](漫画动态规划.assets/640-1564452968276.webp)



![img](漫画动态规划.assets/640-1564452968301.webp)





![img](漫画动态规划.assets/640-1564452968322.webp)





**方法一：排列组合**



每一座金矿都有挖与不挖两种选择，如果有N座金矿，排列组合起来就有2^N种选择。对所有可能性做遍历，排除那些使用工人数超过10的选择，在剩下的选择里找出获得金币数最多的选择。



代码比较简单就不展示了，时间复杂度也很明显，就是O(2^N)。





![img](漫画动态规划.assets/640-1564452968315.webp)





![img](漫画动态规划.assets/640-1564452968367.webp)





![img](漫画动态规划.assets/640-1564452968334.webp)





![img](漫画动态规划.assets/640-1564452968370.webp)





![img](漫画动态规划.assets/640-1564452968356.webp)





![img](漫画动态规划.assets/640-1564452968388.webp)





![img](漫画动态规划.assets/640-1564452968372.webp)





![img](漫画动态规划.assets/640-1564452968421.webp)





![img](漫画动态规划.assets/640-1564452968408.webp)





![img](漫画动态规划.assets/640-1564452968431.webp)





![img](漫画动态规划.assets/640-1564452968439.webp)





![img](漫画动态规划.assets/640-1564452968456.webp)





![img](漫画动态规划.assets/640-1564452968471.webp)





![img](漫画动态规划.assets/640-1564452968487.webp)





![img](漫画动态规划.assets/640-1564452968501.webp)





![img](漫画动态规划.assets/640-1564452968512.webp)





![img](漫画动态规划.assets/640-1564452968527.webp)





![img](漫画动态规划.assets/640-1564452968544.webp)





![img](漫画动态规划.assets/640-1564452968559.webp)





![img](漫画动态规划.assets/640-1564452968575.webp)





![img](漫画动态规划.assets/640-1564452968589.webp)





**F(n,w) = 0    (n<=1, w<p[0]);**



**F(n,w) = g[0]     (n==1, w>=p[0]);**



**F(n,w) = F(n-1,w)    (n>1, w<p[n-1])**  



**F(n,w) = max(F(n-1,w),  F(n-1,w-p[n-1])+g[n-1])    (n>1, w>=p[n-1])**



其中第三条是补充上去的，原因不难理解。





![img](漫画动态规划.assets/640-1564452968602.webp)





![img](漫画动态规划.assets/640-1564452968619.webp)





![img](漫画动态规划.assets/640-1564452968646.webp)





**方法二：简单递归**



把状态转移方程式翻译成递归程序，递归的结束的条件就是方程式当中的边界。因为每个状态有两个最优子结构，所以递归的执行流程类似于一颗高度为N的二叉树。



方法的时间复杂度是O(2^N)。





**方法三：备忘录算法**



在简单递归的基础上增加一个HashMap备忘录，用来存储中间结果。HashMap的Key是一个包含金矿数N和工人数W的对象，Value是最优选择获得的黄金数。



方法的时间复杂度和空间复杂度相同，都等同于备忘录中不同Key的数量。





![img](漫画动态规划.assets/640-1564452968634.webp)





![img](漫画动态规划.assets/640-1564452968653.webp)





![img](漫画动态规划.assets/640-1564452968664.webp)





![img](漫画动态规划.assets/640-1564452968675.webp)





![img](漫画动态规划.assets/640-1564452968688.webp)





![img](漫画动态规划.assets/640-1564452968700.webp)





![img](漫画动态规划.assets/640-1564452968709.webp)





![img](漫画动态规划.assets/640-1564452968728.webp)





![img](漫画动态规划.assets/640-1564452968736.webp)





![img](漫画动态规划.assets/640-1564452968750.webp)





![img](漫画动态规划.assets/640-1564452968760.webp)





![img](漫画动态规划.assets/640-1564452968776.webp)





![img](漫画动态规划.assets/640-1564452968786.webp)





![img](漫画动态规划.assets/640-1564452968801.webp)





![img](漫画动态规划.assets/640-1564452968808.webp)





![img](漫画动态规划.assets/640-1564452968822.webp)





![img](漫画动态规划.assets/640-1564452968829.webp)





![img](漫画动态规划.assets/640-1564452968840.webp)





![img](漫画动态规划.assets/640-1564452968848.webp)





![img](漫画动态规划.assets/640-1564452968861.webp)





![img](漫画动态规划.assets/640-1564452968873.webp)





![img](漫画动态规划.assets/640-1564452968883.webp)





![img](漫画动态规划.assets/640-1564452968896.webp)





![img](漫画动态规划.assets/640-1564452968910.webp)





![img](漫画动态规划.assets/640-1564452968921.webp)





![img](漫画动态规划.assets/640-1564452968931.webp)





![img](漫画动态规划.assets/640-1564452968944.webp)





**方法四：漫画动态规划**



![img](漫画动态规划.assets/640-1564452968958.webp)



方法利用两层迭代，来逐步推导出最终结果。在外层的每一次迭代，也就是对表格每一行的迭代过程中，都会保留上一行的结果数组 preResults，并循环计算当前行的结果数组results。



方法的时间复杂度是 O(n * w)，空间复杂度是(w)。需要注意的是，当金矿只有5座的时候，漫画动态规划的性能优势还没有体现出来。当金矿有10座，甚至更多的时候，漫画动态规划就明显具备了优势。





![img](漫画动态规划.assets/640-1564452968965.webp)





![img](漫画动态规划.assets/640-1564452968976.webp)





![img](漫画动态规划.assets/640-1564452968987.webp)





![img](漫画动态规划.assets/640-1564452968996.webp)





![img](漫画动态规划.assets/640-1564452969007.webp)





![img](漫画动态规划.assets/640-1564452969019.webp)





![img](漫画动态规划.assets/640-1564452969030.webp)





![img](漫画动态规划.assets/640-1564452969042.webp)





![img](漫画动态规划.assets/640-1564452969053.webp)



![img](漫画动态规划.assets/640-1564452969061.webp)





![img](漫画动态规划.assets/640-1564452969074.webp)





![img](漫画动态规划.assets/640-1564452969086.webp)





![img](漫画动态规划.assets/640-1564452969095.webp)





![img](漫画动态规划.assets/640-1564452969105.webp)







—————END—————